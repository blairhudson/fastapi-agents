{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastAPI Agents","text":"<p>FastAPI Agents is the ultimate FastAPI extension for integrating AI agents into your applications. With just a few lines of code, you can create, manage, and secure AI-powered endpoints, enabling you to build smarter, more interactive apps effortlessly. Whether you're a seasoned developer or just exploring AI integrations, FastAPI Agents has you covered! \ud83c\udf89</p>"},{"location":"#features-at-a-glance","title":"\u2728 Features at a Glance","text":"<ul> <li>\ud83e\udd16 Easy Agent Management: Register, organize, and interact with multiple AI agents seamlessly.</li> <li>\ud83d\udd10 Built-In Security: Easily add API key, OAuth2, cookie, or OpenID authentication to your endpoints.</li> <li>\ud83d\udcda Agent Framework Support: Compatible with agent frameworks like PydanticAI, Llama-Index, and HuggingFace Smolagents.</li> <li>\ud83d\udc33 Pre-Built Containers: Easily deploy agents in your favourite framework with ready made containers.</li> <li>\ud83d\udd0c OpenAI Compatibility: Use your APIs with other AI tooling including the OpenAI SDK itself. (Experimental)</li> <li>\ud83d\udee0\ufe0f Extensibility: Support additional agent frameworks by extending the <code>BaseAgent</code> class.</li> <li>\ud83e\udde9 Dynamic Dependencies: Inject and resolve request-specific configurations effortlessly.</li> <li>\ud83d\ude80 Performance Optimized: Leverage FastAPI's high performance and scalability for AI agent interactions.</li> <li>\ud83d\udcd6 Auto-Generated API Documentation: OpenAPI integration for your registered agents, out of the box!</li> </ul> <p>See Releases for the latest updates at and Roadmap for what's coming.</p>"},{"location":"#sponsors","title":"\ud83d\udc96 Sponsors","text":"<p>You can support the ongoing development of FastAPI Agents by becoming a sponsor:</p> <p>Sponsor FastAPI Agents</p>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<p>For further documentation, including detailed API documentation for the available agent frameworks, visit the FastAPI Agents Documentation.</p>"},{"location":"#installation","title":"\ud83d\ude80 Installation","text":"<p>Install <code>FastAPI Agents</code> using pip, poetry or uv:</p> <pre><code>pip install fastapi-agents\npoetry add fastapi-agents\nuv add fastapi-agents\n</code></pre> <p>Install optional extras for your chosen agent frameworks:</p> <pre><code>pip install 'fastapi-agents[pydantic-ai]'\npoetry add fastapi-agents -E pydantic-ai\nuv add fastapi-agents --extra pydantic-ai\n</code></pre> <p>For available extras, replace <code>pydantic-ai</code> with the desired agent framework (e.g. <code>smolagents</code> or <code>llama-index</code>). See pyproject.toml for the full list of extras.</p> <p>That's it! You're all set to start integrating AI agents into your FastAPI applications. \ud83c\udf89</p>"},{"location":"#quick-start","title":"\ud83c\udfc1 Quick Start","text":""},{"location":"#registering-agents","title":"Registering Agents","text":"<p>Here\u2019s how to get started with a basic <code>PydanticAI</code> agent:</p> <pre><code>from fastapi import FastAPI\nfrom fastapi_agents import FastAPIAgents\nfrom fastapi_agents.pydantic_ai import PydanticAIAgent\nfrom pydantic_ai import Agent\n\napp = FastAPI()\nagents = FastAPIAgents(path_prefix=\"/agents\")\n\n# Initialize and register the agent\nagent = Agent(\"openai:gpt-4o-mini\")\nagents.register(\"pydanticai\", PydanticAIAgent(agent))\n\n# Include the router\napp.include_router(agents)\n</code></pre>"},{"location":"#adding-security","title":"Adding Security","text":"<p>Secure your endpoints with API Key authentication in just a few steps:</p> <pre><code>from fastapi.security import APIKeyHeader\nfrom fastapi_agents import FastAPIAgents\n\n# Define API Key validation\ndef validate_api_key(api_key: str = Depends(APIKeyHeader(name=\"X-API-Key\"))):\n    if api_key != \"my-secret-api-key\":\n        raise HTTPException(status_code=403, detail=\"Invalid API Key\")\n\n# Secure the agents\nagents = FastAPIAgents(path_prefix=\"/agents\", security_dependency=validate_api_key)\n</code></pre> <p>\ud83d\udc49 See Security Examples for more details.</p>"},{"location":"#running-the-application","title":"Running the Application","text":"<p>Run your FastAPI application with the registered agents:</p> <pre><code>uvicorn --reload &lt;module&gt;:app\n</code></pre> <p>Replace <code>&lt;module&gt;</code> with the name of the Python module containing your FastAPI application.</p> <p>That's it! You're all set to start building smarter, more secure FastAPI applications with AI agents. \ud83d\ude80</p>"},{"location":"#supported-agents","title":"\ud83e\udd1d Supported Agents","text":"<p><code>FastAPI Agents</code> supports a variety of agent frameworks, including:</p> <ol> <li>PydanticAI: AI agents powered by Pydantic AI. Examples</li> <li>Llama Index: OpenAI agents with Llama Index integration. Examples</li> <li>HuggingFace Smolagents: Lightweight and efficient AI agents. Examples</li> </ol>"},{"location":"#configuration-options","title":"\u2699\ufe0f Configuration Options","text":""},{"location":"#fastapiagents","title":"<code>FastAPIAgents</code>","text":"<p>The <code>FastAPIAgents</code> class is initialized with the following parameters:</p> Parameter Type Default Description <code>path_prefix</code> <code>Optional[str]</code> <code>\"/agents\"</code> The prefix for all agent-related endpoints. Can be set to <code>None</code> for no prefix. <code>security_dependency</code> <code>Optional[Callable]</code> <code>None</code> A global security dependency for all agents. For example, API key or OAuth validation. <code>mode</code> <code>Optional[APIMode]</code> <code>simple</code> Change the way endpoints are registered. <code>simple</code> (default) is one endpoint per agent. <code>openai</code> provides OpenAI compatibility with a <code>GET /models</code> endpoint and a <code>POST /chat/completions</code> endpoint that allows your agents to be selected by changing <code>model=&lt;name&gt;</code> . <code>*args</code> <code>Any</code> <code>-</code> Additional arguments passed to the parent <code>APIRouter</code> class. <code>**kwargs</code> <code>Any</code> <code>-</code> Additional keyword arguments passed to the parent <code>APIRouter</code> class. <p>Example: <pre><code>agents = FastAPIAgents(\n    path_prefix=\"/agents\", \n    security_dependency=validate_api_key\n)\n</code></pre></p>"},{"location":"#fastapiagentsregister","title":"<code>FastAPIAgents.register</code>","text":"<p>The <code>register</code> method is used to add an individual agent. The following parameters are available:</p> Parameter Type Required Default Description <code>name</code> <code>str</code> Yes - The unique name for the agent. This will form part of the endpoint URL. <code>agent</code> <code>BaseAgent</code> Yes - An instance of a class that implements the <code>BaseAgent</code> interface. <code>router</code> <code>Optional[APIRouter]</code> No <code>None</code> A custom router to include this agent. Defaults to the global <code>FastAPIAgents</code> router. <code>tags</code> <code>Optional[List[str]]</code> No <code>[\"Agents\"]</code> Tags to include in the OpenAPI documentation for this agent's endpoints. Not supported in <code>openai</code> mode. <code>description</code> <code>Optional[str]</code> No <code>None</code> A description for the agent's endpoint in the OpenAPI documentation. Not supported in <code>openai</code> mode. <code>security_dependency</code> <code>Optional[Callable]</code> No <code>None</code> A per-agent security dependency, overriding the global <code>security_dependency</code> if set. Not supported in <code>openai</code> mode. <p>Note: A per-agent security dependency cannot be used if a global <code>security_dependency</code> is already defined during initialization or if using <code>openai</code> mode.</p> <p>Example: <pre><code>from fastapi_agents.pydantic_ai import PydanticAIAgent\nfrom pydantic_ai import Agent\n\nagent = Agent(\"openai:gpt-4o-mini\")\n\nagents.register(\n    name=\"pydanticai\",\n    agent=PydanticAIAgent(agent),\n    tags=[\"AI Agents\"],\n    description=\"An agent for handling Pydantic AI interactions.\"\n)\n</code></pre></p>"},{"location":"#using-docker","title":"\ud83d\udc33 Using Docker","text":""},{"location":"#pre-built-images","title":"Pre-Built Images","text":"<p>The simplest way to containerise your agents!</p> <p>Pre-built Docker images for <code>FastAPI Agents</code> are available on GitHub Container Registry (GHCR):</p> <p>Repository: <code>ghcr.io/blairhudson/fastapi-agents</code></p> <p>Tags:   - Framework-specific: <code>pydantic-ai</code>, <code>smolagents</code>, <code>llama-index</code>   - Version-specific: <code>&lt;framework&gt;-&lt;version&gt;</code></p> <p>To pull a specific image:</p> <pre><code>docker pull ghcr.io/blairhudson/fastapi-agents:pydantic-ai\n</code></pre> <p>See all available images and tags in Versions.</p> <p>Currently pre-built images support only one agent per container. If you are creating containers that can serve multiple agents, it is recommended to define your own containers.</p>"},{"location":"#environment-variables","title":"Environment Variables","text":"<p>The pre-built images support the following environment variables for customisation:</p> Variable Example Value Description <code>AGENT_FRAMEWORK</code> <code>pydantic-ai</code> Specifies the agent framework to use. <code>AGENT_MODULE</code> <code>agent.pydantic_ai</code> Path to the agent module. <code>AGENT_CLASS</code> <code>agent</code> Class name for the agent. <code>SECURITY_MODULE</code> <code>agent.pydantic_ai</code> Specifies the security module for the agent. <code>SECURITY_CLASS</code> <code>validate_token</code> Class name for the security depdency. <code>API_ENDPOINT</code> <code>pydantic-ai</code> API endpoint path for the agent. <code>API_PREFIX</code> <code>/agents</code> Prefix for all agent-related API endpoints. <code>API_MODE</code> <code>simple</code> Changes how endpoints are registered. <code>openai</code> changes to OpenAI-compatible endpoints. <code>PORT</code> <code>8080</code> Port the application runs on within the container. <p>To customize these values, pass them as <code>-e</code> arguments to <code>docker run</code> or define them in an <code>.env</code> file.</p>"},{"location":"#volume-mounting","title":"Volume Mounting","text":"<p>Agents are expected to be volume-mounted at <code>/app/agent</code>. You can mount your agent directory as follows:</p> <pre><code>docker run -p 8000:8080 \\\n  -v $(pwd)/agent:/app/agent \\\n  ghcr.io/blairhudson/fastapi-agents:pydantic-ai\n</code></pre> <p>If a <code>requirements.txt</code> file is present in the mounted directory, it will be automatically installed at container startup.</p>"},{"location":"#building-custom-containers","title":"Building Custom Containers","text":"<p>For production deployments, it is recommended to build your container with dependencies included. Here\u2019s an example <code>Dockerfile</code> starting from one of the pre-built base images:</p> <pre><code>FROM ghcr.io/blairhudson/fastapi-agents:pydantic-ai\n\n# Copy your agent source code\nCOPY ./agent /app/agent\n\n# Install dependencies\nRUN pip install --no-cache-dir -r /app/agent/requirements.txt\n</code></pre> <p>Build and run the custom image:</p> <pre><code>docker build -t my-custom-agent .\ndocker run -p 8000:8080 my-custom-agent\n</code></pre> <p>This approach ensures all dependencies are baked into the image, improving startup performance and reliability.</p>"},{"location":"#examples","title":"\ud83d\udca1 Examples","text":"<p>Explore real-world examples for implementing <code>FastAPI Agents</code> in different scenarios:</p> <ul> <li>Agent Frameworks:<ul> <li>PydanticAI</li> <li>Llama-Index</li> <li>Huggingface SmolAgents</li> </ul> </li> <li>Advanced Agent Frameworks:<ul> <li>PydanticAI with Dependencies</li> </ul> </li> <li>Docker:<ul> <li>PydanticAI in Docker</li> </ul> </li> <li>Security Integrations:<ul> <li>API Key Authentication</li> <li>Cookie Authentication</li> <li>OAuth2 Authentication</li> <li>OpenID Connect (OIDC)</li> <li>HTTP Basic Auth</li> </ul> </li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! To contribute:</p> <ol> <li>Fork the repository.</li> <li>Create a feature branch.</li> <li>Add any new tests and ensure they pass. i.e. <code>uv run pytest</code>.</li> <li>Submit a pull request.</li> </ol> <p>For any questions or feature requests including additional agent frameworks, open an issue in the repository.</p>"},{"location":"#citation","title":"\ud83d\udcc4 Citation","text":"<p>If you use FastAPI Agents in your work, please consider citing it using the metadata in the <code>CITATION.cff</code> file:</p> <p></p> <p>This DOI represents all versions of the project. For version-specific DOIs, refer to the Zenodo project page.</p> <p>Alternatively, you can use the following BibTeX entry:</p> <pre><code>@software{fastapi_agents,\n  author = {Blair Hudson},\n  title = {FastAPI Agents},\n  year = {2025},\n  version = {0.1},\n  doi = {10.5281/zenodo.14635504},\n  url = {https://github.com/blairhudson/fastapi-agents},\n  orcid = {https://orcid.org/0009-0007-4216-4555},\n  abstract = {FastAPI Agents is the ultimate FastAPI extension for integrating AI agents into your applications.}\n}\n</code></pre>"},{"location":"#license","title":"\ud83d\udcdc License","text":"<p>This project is licensed under the MIT License. See the <code>LICENSE</code> file for more details.</p>"},{"location":"roadmap/","title":"FastAPI Agents Roadmap","text":""},{"location":"roadmap/#agent-framework-support","title":"Agent Framework support","text":"<ul> <li>[x] Pydantic AI</li> <li>[ ] Pydantic Graph</li> <li>[x] Llama-Index</li> <li>[x] Smolagents</li> <li>[ ] CrewAI</li> <li>[ ] LangChain</li> <li>[ ] LangGraph</li> <li>[ ] Autogen</li> </ul>"},{"location":"roadmap/#api-features","title":"API Features","text":"<ul> <li>[x] Simple mode (one endpoint per agent)</li> <li>[x] Customisable security dependencies</li> <li>[x] Per agent security</li> <li>[x] OpenAI mode</li> <li>[x] Chat Completions endpoint</li> <li>[x] Models endpoint</li> <li>[ ] Streaming</li> <li>[ ] Output tool selection (\"inner thoughts\")</li> <li>[ ] Increased request concurrency</li> </ul>"},{"location":"roadmap/#containers","title":"Containers","text":"<ul> <li>[x] Pre-built Containers for each Agent framework</li> <li>[x] Dynamic requirements.txt</li> <li>[ ] Support for Multiple Agents in one container</li> <li>[ ] Alternative package manager support</li> <li>[ ] Poetry</li> <li>[ ] UV</li> <li>[ ] Reduce container sizes</li> </ul>"},{"location":"roadmap/#developer-experience","title":"Developer experience","text":"<ul> <li>[x] Standalone doc site</li> <li>[x] Examples folder</li> <li>[ ] Examples on doc site</li> <li>[x] Guided notebooks</li> <li>[x] Flexible router attachment</li> <li>[x] Optional FastAPI app creation  </li> <li>[ ] Automatic framework adapter selection</li> <li>[ ] Gradio UI</li> </ul>"},{"location":"roadmap/#contributor-experience","title":"Contributor experience","text":"<ul> <li>[x] Automated tests</li> <li>[ ] Code coverage reporting</li> <li>[ ] Issue templates</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#fastapi_agents.FastAPIAgents","title":"<code>FastAPIAgents</code>","text":"<p>               Bases: <code>APIRouter</code></p> <p>FastAPI router for managing multiple agents.</p> <p>This router is designed to be used with FastAPI to manage multiple agents, each with its own endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>path_prefix</code> <code>str</code> <p>The path prefix for the agents' endpoints. Defaults to \"/agents\".</p> <code>None</code> <code>security_dependency</code> <code>Callable</code> <p>A global security dependency for all agents. Defaults to None.</p> <code>None</code> <code>mode</code> <code>APIMode</code> <p>The mode for registering routes. Defaults to \"simple\". Also available is \"openai\" which registers routes as OpenAI-compatible.</p> <code>'simple'</code> <code>*args</code> <code>list[Any]</code> <p>Additional arguments to pass to the APIRouter parent class.</p> <code>()</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the APIRouter parent class.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a per-agent security dependency is defined when a global security dependency is already set.</p> <p>Example:</p> <pre><code>from fastapi import FastAPI, Depends, HTTPException\nfrom fastapi_agents import FastAPIAgents\nfrom fastapi_agents.pydantic_ai import PydanticAIAgent\nfrom pydantic_ai import Agent\n\n# Initialize FastAPI app\napp = FastAPI()\n\n# Initialize FastAPIAgents\nagents = FastAPIAgents(path_prefix=\"/agents\")\n\n# Register PydanticAI agent\nagent = Agent(\"openai:gpt-4o-mini\")\nagents.register(\"pydanticai\", PydanticAIAgent(agent), tags=[\"AI Agents\"], description=\"Pydantic AI Agent\")\n\n# Include the router\napp.include_router(agents)\n</code></pre> <p>Returns:</p> Name Type Description <code>FastAPIAgents</code> <code>FastAPIAgents</code> <p>A FastAPI router for managing multiple agents.</p> Source code in <code>fastapi_agents/core.py</code> <pre><code>class FastAPIAgents(APIRouter):\n    \"\"\"\n    FastAPI router for managing multiple agents.\n\n    This router is designed to be used with FastAPI to manage multiple agents, each with its own endpoint.\n\n    Args:\n        path_prefix (str, optional): The path prefix for the agents' endpoints. Defaults to \"/agents\".\n        security_dependency (Callable, optional): A global security dependency for all agents. Defaults to None.\n        mode (APIMode, optional): The mode for registering routes. Defaults to \"simple\". Also available is \"openai\" which registers routes as OpenAI-compatible.\n        *args (list[Any], optional): Additional arguments to pass to the APIRouter parent class.\n        **kwargs (dict[str, Any], optional): Additional keyword arguments to pass to the APIRouter parent class.\n\n    Raises:\n        ValueError: If a per-agent security dependency is defined when a global security dependency is already set.\n\n    Example:\n\n        from fastapi import FastAPI, Depends, HTTPException\n        from fastapi_agents import FastAPIAgents\n        from fastapi_agents.pydantic_ai import PydanticAIAgent\n        from pydantic_ai import Agent\n\n        # Initialize FastAPI app\n        app = FastAPI()\n\n        # Initialize FastAPIAgents\n        agents = FastAPIAgents(path_prefix=\"/agents\")\n\n        # Register PydanticAI agent\n        agent = Agent(\"openai:gpt-4o-mini\")\n        agents.register(\"pydanticai\", PydanticAIAgent(agent), tags=[\"AI Agents\"], description=\"Pydantic AI Agent\")\n\n        # Include the router\n        app.include_router(agents)\n\n    Returns:\n        FastAPIAgents (FastAPIAgents): A FastAPI router for managing multiple agents.\n\n    \"\"\"\n    def __init__(\n        self,\n        path_prefix: Optional[str] = None,\n        security_dependency: Optional[Callable] = None,  # Global security dependency\n        mode: Optional[APIMode] = 'simple',\n        *args: Optional[list[Any]],\n        **kwargs: Optional[dict[str, Any]]\n    ):\n        super().__init__(*args, **kwargs)\n\n        # default is '/agents' only if mode is simple\n        if mode == 'simple' and path_prefix is None:\n            path_prefix = '/agents'\n\n        if path_prefix == '/':\n            path_prefix == ''\n\n        # make sure mode is one of APIMode str enum\n        if mode not in APIMode._value2member_map_:\n            raise ValueError(f\"Invalid mode: {mode}. Must be one of {list(APIMode._value2member_map_.keys())}\")        \n        self.mode = mode\n\n        self.agents: Dict[str, BaseAgent] = {}\n        self.path_prefix = path_prefix.rstrip(\"/\") if path_prefix else \"\"\n        self.global_security_dependency = security_dependency  # Store global security\n\n\n    @classmethod\n    def as_app(cls, \n               path_prefix: Optional[str] = None,\n        security_dependency: Optional[Callable] = None,  # Global security dependency\n        mode: Optional[APIMode] = 'simple',\n        *args: Optional[list[Any]],\n        **kwargs: Optional[dict[str, Any]]) -&gt; FastAPI:\n        \"\"\"\n        Creates and returns a FastAPI app with the FastAPIAgents router included, and injects the `register` method for easy registration.\n\n        Args:\n            path_prefix (str, optional): The path prefix for the agents' endpoints. Defaults to \"/agents\".\n            security_dependency (Callable, optional): A global security dependency for all agents. Defaults to None.\n            mode (APIMode, optional): The mode for registering routes. Defaults to \"simple\". Also available is \"openai\" which registers routes as OpenAI-compatible.\n            *args (list[Any], optional): Additional arguments to pass to the APIRouter parent class.\n            **kwargs (dict[str, Any], optional): Additional keyword arguments to pass to the APIRouter parent class.\n\n        Returns:\n            FastAPI: A FastAPI app instance with the router included and registration capability.\n        \"\"\"\n        # Initialize the FastAPIAgents instance\n        agents_router = cls(path_prefix, security_dependency, mode, *args, **kwargs)\n\n        # Create a FastAPI app\n        app = FastAPI()\n\n        # Include the router in the FastAPI app\n        app.include_router(agents_router)\n\n        # Add a generic register method to the app\n        def register(*register_args, **register_kwargs):\n            agents_router.register(*register_args, **register_kwargs)\n            app.include_router(agents_router)\n\n        app.register = register  # Attach the register method to the app\n\n        return app\n\n    def register(\n        self,\n        name: str,\n        agent: BaseAgent,\n        router: Optional[APIRouter] = None,\n        tags: Optional[List[str]] = None,\n        description: Optional[str] = None,\n        security_dependency: Optional[Callable] = None,  # Optional per-agent security\n    ):\n        \"\"\"\n        Register an agent with the FastAPI router.\n\n        Args:\n            name (str): The name of the agent.\n            agent (BaseAgent): The agent instance to register.\n            router (APIRouter, optional): The router to use for the agent endpoint. Defaults to None.\n            tags (List[str], optional): The tags to assign to the agent endpoint. Defaults to None.\n            description (str, optional): The description of the agent endpoint. Defaults to None.\n            security_dependency (Callable, optional): A per-agent security dependency. Defaults to None.\n\n        Raises:\n            ValueError: If a per-agent security dependency is defined when a global security dependency is already set.\n            AgentNotFoundError: If the agent is not found in the registry.\n        \"\"\"\n        # Error if attempting to override global security\n        if self.global_security_dependency and security_dependency:\n            raise ValueError(\n                f\"Cannot set a per-agent security dependency for '{name}' \"\n                \"because a global security dependency is already defined.\"\n            )\n\n        if name in self.agents.keys():\n            raise ValueError(f\"Agent '{name}' is already registered.\")\n\n        if not issubclass(type(agent), BaseAgent):\n            raise TypeError(f\"Provided agent is not a subclass of BaseAgent. Did you use an adapter?\")\n        self.agents[name] = agent\n\n        target_router = router or self\n\n        if self.mode == \"simple\":\n\n            # Use global security if no per-agent security is defined\n            effective_security = security_dependency or self.global_security_dependency\n\n            route_path = f\"{self.path_prefix}/{name}\" if self.path_prefix else f\"/{name}\"\n\n            if effective_security:\n                # Endpoint with security\n                @target_router.post(route_path, tags=tags or [\"Agents\"], description=description)\n                async def agent_endpoint(\n                    payload: RequestPayload,\n                    token: str = Depends(effective_security),  # Extract token via security dependency\n                    agent: BaseAgent = Depends(self._get_agent(name)),\n                ) -&gt; ResponsePayload:\n                    try:\n                        # Log the token for debugging\n                        logger.info(f\"Token received for agent '{name}': {token}\")\n\n                        # Process the agent logic\n                        result = await agent.run(payload)\n                        return JSONResponse({\"message\": {\"role\": \"assistant\", \"content\": result}})\n                    except Exception as e:\n                        logger.error(f\"Error in endpoint for agent '{name}': {e}\")\n                        raise HTTPException(status_code=500, detail=str(e))\n            else:\n                # Endpoint without security\n                @target_router.post(route_path, tags=tags or [\"Agents\"], description=description)\n                async def agent_endpoint(\n                    payload: RequestPayload,\n                    agent: BaseAgent = Depends(self._get_agent(name)),\n                ) -&gt; ResponsePayload:\n                    try:\n                        # Process the agent logic\n                        result = await agent.run(payload)\n                        return JSONResponse({\"message\": {\"role\": \"assistant\", \"content\": result}})\n                    except Exception as e:\n                        logger.error(f\"Error in endpoint for agent '{name}': {e}\")\n                        raise HTTPException(status_code=500, detail=str(e))\n\n        elif self.mode == \"openai\":\n\n            if tags:\n                warnings.warn(\"Tags provided in openai mode are not used.\")\n\n            if description:\n                warnings.warn(\"Descriptions provided in openai mode are not used.\")\n\n            if security_dependency:\n                raise ValueError(f\"Security dependency can only be provided globally in openai mode.\") \n\n            existing_routes = {(route.path, frozenset(route.methods)) for route in target_router.routes}\n\n            models_path = f\"{self.path_prefix}/models\" if self.path_prefix else f\"/models\"\n\n            if (models_path, frozenset({'GET'})) not in existing_routes:\n\n                if self.global_security_dependency:\n                    @target_router.get(models_path, tags=['Models'], description=\"List and describe the various models available in the API.\")\n                    async def list_models(token: str = Depends(self.global_security_dependency)) -&gt; JSONResponse:\n                        return JSONResponse({\n                            \"object\": \"list\",\n                            \"data\": [{\"id\": key, \"object\": \"model\", \"created\": int(os.path.getmtime(__file__)), \"owned_by\": \"openai\"} for key in self.agents.keys()]\n                        })\n                else:\n                    @target_router.get(models_path, tags=['Models'], description=\"List and describe the various models available in the API.\")\n                    async def list_models() -&gt; JSONResponse:\n                        return JSONResponse({\n                            \"object\": \"list\",\n                            \"data\": [{\"id\": key, \"object\": \"model\", \"created\": int(os.path.getmtime(__file__)), \"owned_by\": \"openai\"} for key in self.agents.keys()]\n                        })\n\n            chat_completions_path = f\"{self.path_prefix}/chat/completions\" if self.path_prefix else f\"/chat/completions\"\n\n            if (chat_completions_path, frozenset({'POST'})) not in existing_routes:\n                if self.global_security_dependency:\n                    @target_router.post(chat_completions_path, tags=[\"Chat\"], description=\"Given a list of messages comprising a conversation, the model will return a response.\")\n                    async def chat_completion(payload: OpenAIRequestPayload, token: str = Depends(self.global_security_dependency)) -&gt; OpenAIResponsePayload:\n                        validated_payload = OpenAIRequestPayload.model_validate(payload)\n                        name = validated_payload.model\n\n                        try:\n                            agent = self._get_agent(name)()\n                            result = await agent.run(validated_payload)\n                            return OpenAIResponsePayload(\n                                id=\"chatcmpl-123\",\n                                object=\"chat.completion\",\n                                model=name,\n                                created=int(time.time()),\n                                choices=[Choice(index=0,\n                                    message=Message(role=\"assistant\", content=result),\n                                    finish_reason=\"stop\"\n                                )]\n                            ).model_dump()\n\n                        except Exception as e:\n                            logger.error(f\"Error in endpoint for agent '{name}': {e}\")\n                            raise HTTPException(status_code=500, detail=str(e))\n\n                else:\n                    @target_router.post(chat_completions_path, tags=[\"Chat\"], description=\"Given a list of messages comprising a conversation, the model will return a response.\")\n                    async def chat_completion(payload: OpenAIRequestPayload) -&gt; OpenAIResponsePayload:\n                        validated_payload = OpenAIRequestPayload.model_validate(payload)\n                        name = validated_payload.model\n\n                        try:\n                            agent = self._get_agent(name)()\n                            result = await agent.run(validated_payload)\n                            return OpenAIResponsePayload(\n                                id=\"chatcmpl-123\",\n                                object=\"chat.completion\",\n                                model=name,\n                                created=int(time.time()),\n                                choices=[Choice(index=0,\n                                    message=Message(role=\"assistant\", content=result),\n                                    finish_reason=\"stop\"\n                                )]\n                            ).model_dump()\n\n                        except Exception as e:\n                            logger.error(f\"Error in endpoint for agent '{name}': {e}\")\n                            raise HTTPException(status_code=500, detail=str(e))\n\n    def _get_agent(self, name: str) -&gt; Callable[[], BaseAgent]:\n        def _get_agent_instance():\n            agent = self.agents.get(name)\n            if not agent:\n                raise AgentNotFoundError(name)\n            return agent\n\n        return _get_agent_instance\n</code></pre>"},{"location":"api/#fastapi_agents.FastAPIAgents.as_app","title":"<code>as_app(path_prefix=None, security_dependency=None, mode='simple', *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates and returns a FastAPI app with the FastAPIAgents router included, and injects the <code>register</code> method for easy registration.</p> <p>Parameters:</p> Name Type Description Default <code>path_prefix</code> <code>str</code> <p>The path prefix for the agents' endpoints. Defaults to \"/agents\".</p> <code>None</code> <code>security_dependency</code> <code>Callable</code> <p>A global security dependency for all agents. Defaults to None.</p> <code>None</code> <code>mode</code> <code>APIMode</code> <p>The mode for registering routes. Defaults to \"simple\". Also available is \"openai\" which registers routes as OpenAI-compatible.</p> <code>'simple'</code> <code>*args</code> <code>list[Any]</code> <p>Additional arguments to pass to the APIRouter parent class.</p> <code>()</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the APIRouter parent class.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>FastAPI</code> <code>FastAPI</code> <p>A FastAPI app instance with the router included and registration capability.</p> Source code in <code>fastapi_agents/core.py</code> <pre><code>@classmethod\ndef as_app(cls, \n           path_prefix: Optional[str] = None,\n    security_dependency: Optional[Callable] = None,  # Global security dependency\n    mode: Optional[APIMode] = 'simple',\n    *args: Optional[list[Any]],\n    **kwargs: Optional[dict[str, Any]]) -&gt; FastAPI:\n    \"\"\"\n    Creates and returns a FastAPI app with the FastAPIAgents router included, and injects the `register` method for easy registration.\n\n    Args:\n        path_prefix (str, optional): The path prefix for the agents' endpoints. Defaults to \"/agents\".\n        security_dependency (Callable, optional): A global security dependency for all agents. Defaults to None.\n        mode (APIMode, optional): The mode for registering routes. Defaults to \"simple\". Also available is \"openai\" which registers routes as OpenAI-compatible.\n        *args (list[Any], optional): Additional arguments to pass to the APIRouter parent class.\n        **kwargs (dict[str, Any], optional): Additional keyword arguments to pass to the APIRouter parent class.\n\n    Returns:\n        FastAPI: A FastAPI app instance with the router included and registration capability.\n    \"\"\"\n    # Initialize the FastAPIAgents instance\n    agents_router = cls(path_prefix, security_dependency, mode, *args, **kwargs)\n\n    # Create a FastAPI app\n    app = FastAPI()\n\n    # Include the router in the FastAPI app\n    app.include_router(agents_router)\n\n    # Add a generic register method to the app\n    def register(*register_args, **register_kwargs):\n        agents_router.register(*register_args, **register_kwargs)\n        app.include_router(agents_router)\n\n    app.register = register  # Attach the register method to the app\n\n    return app\n</code></pre>"},{"location":"api/#fastapi_agents.FastAPIAgents.register","title":"<code>register(name, agent, router=None, tags=None, description=None, security_dependency=None)</code>","text":"<p>Register an agent with the FastAPI router.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the agent.</p> required <code>agent</code> <code>BaseAgent</code> <p>The agent instance to register.</p> required <code>router</code> <code>APIRouter</code> <p>The router to use for the agent endpoint. Defaults to None.</p> <code>None</code> <code>tags</code> <code>List[str]</code> <p>The tags to assign to the agent endpoint. Defaults to None.</p> <code>None</code> <code>description</code> <code>str</code> <p>The description of the agent endpoint. Defaults to None.</p> <code>None</code> <code>security_dependency</code> <code>Callable</code> <p>A per-agent security dependency. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a per-agent security dependency is defined when a global security dependency is already set.</p> <code>AgentNotFoundError</code> <p>If the agent is not found in the registry.</p> Source code in <code>fastapi_agents/core.py</code> <pre><code>def register(\n    self,\n    name: str,\n    agent: BaseAgent,\n    router: Optional[APIRouter] = None,\n    tags: Optional[List[str]] = None,\n    description: Optional[str] = None,\n    security_dependency: Optional[Callable] = None,  # Optional per-agent security\n):\n    \"\"\"\n    Register an agent with the FastAPI router.\n\n    Args:\n        name (str): The name of the agent.\n        agent (BaseAgent): The agent instance to register.\n        router (APIRouter, optional): The router to use for the agent endpoint. Defaults to None.\n        tags (List[str], optional): The tags to assign to the agent endpoint. Defaults to None.\n        description (str, optional): The description of the agent endpoint. Defaults to None.\n        security_dependency (Callable, optional): A per-agent security dependency. Defaults to None.\n\n    Raises:\n        ValueError: If a per-agent security dependency is defined when a global security dependency is already set.\n        AgentNotFoundError: If the agent is not found in the registry.\n    \"\"\"\n    # Error if attempting to override global security\n    if self.global_security_dependency and security_dependency:\n        raise ValueError(\n            f\"Cannot set a per-agent security dependency for '{name}' \"\n            \"because a global security dependency is already defined.\"\n        )\n\n    if name in self.agents.keys():\n        raise ValueError(f\"Agent '{name}' is already registered.\")\n\n    if not issubclass(type(agent), BaseAgent):\n        raise TypeError(f\"Provided agent is not a subclass of BaseAgent. Did you use an adapter?\")\n    self.agents[name] = agent\n\n    target_router = router or self\n\n    if self.mode == \"simple\":\n\n        # Use global security if no per-agent security is defined\n        effective_security = security_dependency or self.global_security_dependency\n\n        route_path = f\"{self.path_prefix}/{name}\" if self.path_prefix else f\"/{name}\"\n\n        if effective_security:\n            # Endpoint with security\n            @target_router.post(route_path, tags=tags or [\"Agents\"], description=description)\n            async def agent_endpoint(\n                payload: RequestPayload,\n                token: str = Depends(effective_security),  # Extract token via security dependency\n                agent: BaseAgent = Depends(self._get_agent(name)),\n            ) -&gt; ResponsePayload:\n                try:\n                    # Log the token for debugging\n                    logger.info(f\"Token received for agent '{name}': {token}\")\n\n                    # Process the agent logic\n                    result = await agent.run(payload)\n                    return JSONResponse({\"message\": {\"role\": \"assistant\", \"content\": result}})\n                except Exception as e:\n                    logger.error(f\"Error in endpoint for agent '{name}': {e}\")\n                    raise HTTPException(status_code=500, detail=str(e))\n        else:\n            # Endpoint without security\n            @target_router.post(route_path, tags=tags or [\"Agents\"], description=description)\n            async def agent_endpoint(\n                payload: RequestPayload,\n                agent: BaseAgent = Depends(self._get_agent(name)),\n            ) -&gt; ResponsePayload:\n                try:\n                    # Process the agent logic\n                    result = await agent.run(payload)\n                    return JSONResponse({\"message\": {\"role\": \"assistant\", \"content\": result}})\n                except Exception as e:\n                    logger.error(f\"Error in endpoint for agent '{name}': {e}\")\n                    raise HTTPException(status_code=500, detail=str(e))\n\n    elif self.mode == \"openai\":\n\n        if tags:\n            warnings.warn(\"Tags provided in openai mode are not used.\")\n\n        if description:\n            warnings.warn(\"Descriptions provided in openai mode are not used.\")\n\n        if security_dependency:\n            raise ValueError(f\"Security dependency can only be provided globally in openai mode.\") \n\n        existing_routes = {(route.path, frozenset(route.methods)) for route in target_router.routes}\n\n        models_path = f\"{self.path_prefix}/models\" if self.path_prefix else f\"/models\"\n\n        if (models_path, frozenset({'GET'})) not in existing_routes:\n\n            if self.global_security_dependency:\n                @target_router.get(models_path, tags=['Models'], description=\"List and describe the various models available in the API.\")\n                async def list_models(token: str = Depends(self.global_security_dependency)) -&gt; JSONResponse:\n                    return JSONResponse({\n                        \"object\": \"list\",\n                        \"data\": [{\"id\": key, \"object\": \"model\", \"created\": int(os.path.getmtime(__file__)), \"owned_by\": \"openai\"} for key in self.agents.keys()]\n                    })\n            else:\n                @target_router.get(models_path, tags=['Models'], description=\"List and describe the various models available in the API.\")\n                async def list_models() -&gt; JSONResponse:\n                    return JSONResponse({\n                        \"object\": \"list\",\n                        \"data\": [{\"id\": key, \"object\": \"model\", \"created\": int(os.path.getmtime(__file__)), \"owned_by\": \"openai\"} for key in self.agents.keys()]\n                    })\n\n        chat_completions_path = f\"{self.path_prefix}/chat/completions\" if self.path_prefix else f\"/chat/completions\"\n\n        if (chat_completions_path, frozenset({'POST'})) not in existing_routes:\n            if self.global_security_dependency:\n                @target_router.post(chat_completions_path, tags=[\"Chat\"], description=\"Given a list of messages comprising a conversation, the model will return a response.\")\n                async def chat_completion(payload: OpenAIRequestPayload, token: str = Depends(self.global_security_dependency)) -&gt; OpenAIResponsePayload:\n                    validated_payload = OpenAIRequestPayload.model_validate(payload)\n                    name = validated_payload.model\n\n                    try:\n                        agent = self._get_agent(name)()\n                        result = await agent.run(validated_payload)\n                        return OpenAIResponsePayload(\n                            id=\"chatcmpl-123\",\n                            object=\"chat.completion\",\n                            model=name,\n                            created=int(time.time()),\n                            choices=[Choice(index=0,\n                                message=Message(role=\"assistant\", content=result),\n                                finish_reason=\"stop\"\n                            )]\n                        ).model_dump()\n\n                    except Exception as e:\n                        logger.error(f\"Error in endpoint for agent '{name}': {e}\")\n                        raise HTTPException(status_code=500, detail=str(e))\n\n            else:\n                @target_router.post(chat_completions_path, tags=[\"Chat\"], description=\"Given a list of messages comprising a conversation, the model will return a response.\")\n                async def chat_completion(payload: OpenAIRequestPayload) -&gt; OpenAIResponsePayload:\n                    validated_payload = OpenAIRequestPayload.model_validate(payload)\n                    name = validated_payload.model\n\n                    try:\n                        agent = self._get_agent(name)()\n                        result = await agent.run(validated_payload)\n                        return OpenAIResponsePayload(\n                            id=\"chatcmpl-123\",\n                            object=\"chat.completion\",\n                            model=name,\n                            created=int(time.time()),\n                            choices=[Choice(index=0,\n                                message=Message(role=\"assistant\", content=result),\n                                finish_reason=\"stop\"\n                            )]\n                        ).model_dump()\n\n                    except Exception as e:\n                        logger.error(f\"Error in endpoint for agent '{name}': {e}\")\n                        raise HTTPException(status_code=500, detail=str(e))\n</code></pre>"},{"location":"api/errors/","title":"API Reference","text":""},{"location":"api/errors/#fastapi_agents.errors.AgentNotFoundError","title":"<code>AgentNotFoundError</code>","text":"<p>               Bases: <code>HTTPException</code></p> <p>Exception raised when an agent is not found in the registry.</p> <p>Parameters:</p> Name Type Description Default <code>agent_name</code> <code>str</code> <p>The name of the agent that was not found.</p> required <p>Returns:</p> Name Type Description <code>AgentNotFoundError</code> <p>An instance of the AgentNotFoundError exception.</p> Source code in <code>fastapi_agents/errors.py</code> <pre><code>class AgentNotFoundError(HTTPException):\n    \"\"\"\n    Exception raised when an agent is not found in the registry.\n\n    Args:\n        agent_name (str): The name of the agent that was not found.\n\n    Returns:\n        AgentNotFoundError: An instance of the AgentNotFoundError exception.\n\n    \"\"\"\n    def __init__(self, agent_name: str):\n        super().__init__(status_code=404, detail=f\"Agent '{agent_name}' not found\")\n</code></pre>"},{"location":"api/errors/#fastapi_agents.errors.InvalidPayloadError","title":"<code>InvalidPayloadError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Exception raised when an invalid payload is provided to an agent.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to display. Defaults to \"Invalid payload provided\".</p> <code>'Invalid payload provided'</code> <p>Returns:</p> Name Type Description <code>InvalidPayloadError</code> <p>An instance of the InvalidPayloadError exception.</p> Source code in <code>fastapi_agents/errors.py</code> <pre><code>class InvalidPayloadError(ValueError):\n    \"\"\"\n    Exception raised when an invalid payload is provided to an agent.\n\n    Args:\n        message (str, optional): The error message to display. Defaults to \"Invalid payload provided\".\n\n    Returns:\n        InvalidPayloadError: An instance of the InvalidPayloadError exception.\n\n    \"\"\"\n    def __init__(self, message: str = \"Invalid payload provided\"):\n        super().__init__(message)\n</code></pre>"},{"location":"api/llama_index/","title":"API Reference","text":""},{"location":"api/llama_index/#fastapi_agents.llama_index.LlamaIndexAgent","title":"<code>LlamaIndexAgent</code>","text":"<p>               Bases: <code>AgentRunner</code></p> <p>Adapter class to wrap a LlamaIndex agent for use with FastAPIAgents.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Callable[[AgentRunner], Any]</code> <p>The LlamaIndex agent.</p> required <p>Example:</p> <pre><code>from fastapi_agents.llama_index import LlamaIndexAgent\nfrom llama_index.agent.openai import OpenAIAgent\nfrom llama_index.llms.openai import OpenAI\n\nagent = OpenAIAgent.from_llm(tools=None, llm=OpenAI(\"gpt-4o-mini\"))\nagents.register(\"llamaindex\", LlamaIndexAgent(agent))\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the agent is not a LlamaIndex agent.</p> <p>Returns:</p> Name Type Description <code>LlamaIndexAgent</code> <p>A LlamaIndex agent.</p> Source code in <code>fastapi_agents/llama_index.py</code> <pre><code>class LlamaIndexAgent(AgentRunner):\n    \"\"\"\n    Adapter class to wrap a LlamaIndex agent for use with FastAPIAgents.\n\n    Parameters:\n        agent (Callable[[AgentRunner], Any]): The LlamaIndex agent.\n\n    Example:\n\n        from fastapi_agents.llama_index import LlamaIndexAgent\n        from llama_index.agent.openai import OpenAIAgent\n        from llama_index.llms.openai import OpenAI\n\n        agent = OpenAIAgent.from_llm(tools=None, llm=OpenAI(\"gpt-4o-mini\"))\n        agents.register(\"llamaindex\", LlamaIndexAgent(agent))\n\n    Raises:\n        ValueError: If the agent is not a LlamaIndex agent.\n\n    Returns:\n        LlamaIndexAgent: A LlamaIndex agent.\n\n    \"\"\"\n    def __init__(self, agent: Callable[[AgentRunner], Any]):\n        self.agent = agent\n\n        if not isinstance(agent, AgentRunner):\n            raise ValueError(\"Agent is not a LlamaIndex agent.\")\n\n    async def run(self, payload: RequestPayload) -&gt; dict:\n        validated_payload = RequestPayload(**payload.dict())\n        logger.info(f\"Validated payload: {validated_payload}\")\n\n        # get last content from payload messages where role is user\n        chat_message = [message for message in validated_payload.messages if message.role == \"user\"][-1]\n\n        chat_history = convert_messages_to_llamaindex({\"messages\": validated_payload.messages})\n\n        response = await self.agent.achat(chat_message.content, chat_history=chat_history)\n        return response.response\n</code></pre>"},{"location":"api/llama_index/#fastapi_agents.llama_index.convert_messages_to_llamaindex","title":"<code>convert_messages_to_llamaindex(messages)</code>","text":"<p>Converts messages e.g. {\"messages\": [{\"role\":\"role\",\"content\":\"content\"}]} to LlamaIndex ChatMessage objects.</p> Source code in <code>fastapi_agents/llama_index.py</code> <pre><code>def convert_messages_to_llamaindex(messages: dict) -&gt; List[ChatMessage]:\n    \"\"\"Converts messages e.g. {\"messages\": [{\"role\":\"role\",\"content\":\"content\"}]} to LlamaIndex ChatMessage objects.\"\"\"\n    return [ChatMessage(content=message.content, role=message.role) for message in messages[\"messages\"]]\n</code></pre>"},{"location":"api/models/","title":"API Reference","text":""},{"location":"api/models/#fastapi_agents.models.APIMode","title":"<code>APIMode</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Mode for registering routes to FastAPI.</p> Values <ul> <li><code>simple</code>: Standard mode with minimal configuration.</li> <li><code>openai</code>: OpenAI-compatible mode for additional functionality.</li> </ul> Source code in <code>fastapi_agents/models.py</code> <pre><code>class APIMode(str, Enum):\n    \"\"\"\n    Mode for registering routes to FastAPI.\n\n    Values:\n        - `simple`: Standard mode with minimal configuration.\n        - `openai`: OpenAI-compatible mode for additional functionality.\n    \"\"\"\n\n    SIMPLE = \"simple\"\n    OPENAI = \"openai\"\n</code></pre>"},{"location":"api/models/#fastapi_agents.models.BaseAgent","title":"<code>BaseAgent</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for an agent.</p> Source code in <code>fastapi_agents/models.py</code> <pre><code>class BaseAgent(ABC):\n    \"\"\"\n    Base class for an agent.\n    \"\"\"\n    @abstractmethod\n    async def run(self, payload: RequestPayload) -&gt; dict:\n        \"\"\"\n        Run the agent with the given payload.\n\n        Args:\n            payload (RequestPayload): The payload for the agent.\n\n        Returns:\n            dict: The response from the agent.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/models/#fastapi_agents.models.BaseAgent.run","title":"<code>run(payload)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Run the agent with the given payload.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>RequestPayload</code> <p>The payload for the agent.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The response from the agent.</p> Source code in <code>fastapi_agents/models.py</code> <pre><code>@abstractmethod\nasync def run(self, payload: RequestPayload) -&gt; dict:\n    \"\"\"\n    Run the agent with the given payload.\n\n    Args:\n        payload (RequestPayload): The payload for the agent.\n\n    Returns:\n        dict: The response from the agent.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/models/#fastapi_agents.models.Message","title":"<code>Message</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Message object in the conversation.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content of the message.</p> required <code>role</code> <code>Role</code> <p>The role of the message in the conversation.</p> required <p>Returns:</p> Name Type Description <code>Message</code> <p>An instance of the Message object.</p> Source code in <code>fastapi_agents/models.py</code> <pre><code>class Message(BaseModel):\n    \"\"\"\n    Message object in the conversation.\n\n    Args:\n        content (str): The content of the message.\n        role (Role): The role of the message in the conversation.\n\n    Returns:\n        Message: An instance of the Message object.\n    \"\"\"\n    content: str\n    role: Role\n</code></pre>"},{"location":"api/models/#fastapi_agents.models.RequestPayload","title":"<code>RequestPayload</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request payload for the agent endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>List[Message]</code> <p>A list of messages in the conversation.</p> required <p>Returns:</p> Name Type Description <code>RequestPayload</code> <p>An instance of the RequestPayload object.</p> Source code in <code>fastapi_agents/models.py</code> <pre><code>class RequestPayload(BaseModel):\n    \"\"\"\n    Request payload for the agent endpoint.\n\n    Args:\n        messages (List[Message]): A list of messages in the conversation.\n\n    Returns:\n        RequestPayload: An instance of the RequestPayload object.\n    \"\"\"\n    messages: List[Message]\n</code></pre>"},{"location":"api/models/#fastapi_agents.models.ResponsePayload","title":"<code>ResponsePayload</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response payload for the agent endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The message to return in the response.</p> required <p>Returns:</p> Name Type Description <code>ResponsePayload</code> <p>An instance of the ResponsePayload object.</p> Source code in <code>fastapi_agents/models.py</code> <pre><code>class ResponsePayload(BaseModel):\n    \"\"\"\n    Response payload for the agent endpoint.\n\n    Args:\n        message (Message): The message to return in the response.\n\n    Returns:\n        ResponsePayload: An instance of the ResponsePayload object.\n    \"\"\"\n    message: Message\n</code></pre>"},{"location":"api/models/#fastapi_agents.models.Role","title":"<code>Role</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Role of the message in the conversation.</p> Values <ul> <li><code>user</code>: Messages sent by the user.</li> <li><code>assistant</code>: Messages sent by the agent.</li> </ul> Source code in <code>fastapi_agents/models.py</code> <pre><code>class Role(str, Enum):\n    \"\"\"\n    Role of the message in the conversation.\n\n    Values:\n        - `user`: Messages sent by the user.\n        - `assistant`: Messages sent by the agent.\n    \"\"\"\n    USER = \"user\"\n    ASSISTANT = \"assistant\"\n</code></pre>"},{"location":"api/pydantic_ai/","title":"API Reference","text":""},{"location":"api/pydantic_ai/#fastapi_agents.pydantic_ai.PydanticAIAgent","title":"<code>PydanticAIAgent</code>","text":"<p>               Bases: <code>BaseAgent</code></p> <p>Adapter class to wrap a Pydantic AI Agent for use with FastAPIAgents and resolve runtime dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The Pydantic AI Agent with <code>deps_type</code> specified.</p> required <code>deps</code> <code>Optional[Callable[[], Any]]</code> <p>Optional function to resolve runtime dependencies.</p> <code>None</code> <p>Example:</p> <pre><code>from fastapi_agents.pydantic_ai import PydanticAIAgent\nfrom pydantic_ai import Agent\n\nagent = Agent(\"openai:gpt-4o-mini\")\npydantic_ai_agent = PydanticAIAgent(agent)\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the agent has <code>deps_type</code> specified, but <code>deps</code> resolver is not provided.</p> <code>ValueError</code> <p>If the agent does not have <code>deps_type</code> specified, but <code>deps</code> resolver is provided.</p> <p>Returns:</p> Name Type Description <code>PydanticAIAgent</code> <p>A Pydantic AI Agent with runtime dependency resolution.</p> Source code in <code>fastapi_agents/pydantic_ai.py</code> <pre><code>class PydanticAIAgent(BaseAgent):\n    \"\"\"\n    Adapter class to wrap a Pydantic AI Agent for use with FastAPIAgents and resolve runtime dependencies.\n\n    Parameters:\n        agent (Agent): The Pydantic AI Agent with `deps_type` specified.\n        deps (Optional[Callable[[], Any]]): Optional function to resolve runtime dependencies.\n\n    Example:\n\n        from fastapi_agents.pydantic_ai import PydanticAIAgent\n        from pydantic_ai import Agent\n\n        agent = Agent(\"openai:gpt-4o-mini\")\n        pydantic_ai_agent = PydanticAIAgent(agent)\n\n    Raises:\n        ValueError: If the agent has `deps_type` specified, but `deps` resolver is not provided.\n        ValueError: If the agent does not have `deps_type` specified, but `deps` resolver is provided.\n\n    Returns:\n        PydanticAIAgent: A Pydantic AI Agent with runtime dependency resolution.\n    \"\"\"\n    def __init__(\n        self,\n        agent: Agent,  # The Pydantic AI Agent with deps_type\n        deps: Optional[Callable[[], Any]] = None,  # Optional function to resolve runtime dependencies\n    ):\n        self.agent = agent\n\n        if self.agent._deps_type is not NoneType and not deps:\n            raise ValueError(\n                \"Agent has `deps_type` specified, but `deps` resolver is not provided.\"\n            )\n        if not self.agent._deps_type and deps:\n            raise ValueError(\n                \"Agent does not have `deps_type` specified, but `deps` resolver is provided.\"\n            )\n        self.deps = deps\n\n    async def run(self, payload: RequestPayload) -&gt; dict:\n        try:\n            # Validate and parse the payload\n            logger.info(f\"Payload received: {payload}\")\n            message_history = convert_messages_to_pydanticai({\"messages\": payload.messages})\n\n            # Extract the user prompt\n            user_prompt_message = next(\n                (\n                    msg.parts[0].content\n                    for msg in reversed(message_history)\n                    if isinstance(msg, ModelRequest) and any(\n                        isinstance(part, UserPromptPart) for part in msg.parts\n                    )\n                ),\n                None,\n            )\n            if not user_prompt_message:\n                raise InvalidPayloadError(\"No user prompt found in the provided messages.\")\n\n            # Resolve runtime dependencies if `deps` is provided\n            validated_deps = None\n            if self.deps:\n                deps_values = await self.deps()\n                if self.agent._deps_type:\n                    validated_deps = self.agent._deps_type(**deps_values)\n\n            # Prepare arguments for the agent\n            kwargs = {\n                \"user_prompt\": user_prompt_message,\n                \"message_history\": message_history[:-1],  # Exclude the last message\n            }\n            if validated_deps:\n                kwargs[\"deps\"] = validated_deps\n\n            # Call the underlying agent\n            response = await self.agent.run(**kwargs)\n\n            return response.data if hasattr(response, \"data\") else \"\"\n\n        except Exception as e:\n            logger.error(f\"Error in PydanticAIAgent: {e}\")\n            raise\n</code></pre>"},{"location":"api/smolagents/","title":"API Reference","text":""},{"location":"api/smolagents/#fastapi_agents.smolagents.SmolagentsAgent","title":"<code>SmolagentsAgent</code>","text":"<p>               Bases: <code>MultiStepAgent</code></p> <p>Adapter class for the Smolagents library for use with FastAPIAgents.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>MultiStepAgent</code> <p>The Smolagents agent.</p> required <p>Example:</p> <pre><code>from fastapi_agents.smolagents import SmolagentsAgent\nfrom smolagents import LiteLLMModel\nfrom smolagents import ToolCallingAgent\n\nmodel = LiteLLMModel(\"gpt-4o-mini\")\nagent = ToolCallingAgent(tools=[], model=model)\nagents.register(\"smolagents\", SmolagentsAgent(agent))\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the role is not \"user\" and there are more than one messages. </p> <p>Returns:</p> Name Type Description <code>SmolagentsAgent</code> <p>A Smolagents agent.</p> Source code in <code>fastapi_agents/smolagents.py</code> <pre><code>class SmolagentsAgent(MultiStepAgent):\n    \"\"\"\n    Adapter class for the Smolagents library for use with FastAPIAgents.\n\n    Parameters:\n        agent (MultiStepAgent): The Smolagents agent.\n\n    Example:\n\n        from fastapi_agents.smolagents import SmolagentsAgent\n        from smolagents import LiteLLMModel\n        from smolagents import ToolCallingAgent\n\n        model = LiteLLMModel(\"gpt-4o-mini\")\n        agent = ToolCallingAgent(tools=[], model=model)\n        agents.register(\"smolagents\", SmolagentsAgent(agent))\n\n    Raises:\n        ValueError: If the role is not \"user\" and there are more than one messages. \n\n    Returns:\n        SmolagentsAgent: A Smolagents agent.\n    \"\"\"\n    def __init__(self, agent: MultiStepAgent):\n        self.agent = agent\n\n    async def run(self, payload: RequestPayload) -&gt; dict:\n        validated_payload = RequestPayload(**payload.dict())\n        logger.info(f\"Validated payload: {validated_payload}\")\n\n        # if messages len &gt; 1 and role is not user, return error\n        if len(validated_payload.messages) &gt; 1 and not all([message.role == \"user\" for message in validated_payload.messages]):\n            raise ValueError(\"Only one user message is allowed.\")\n\n        result = self.agent.run(validated_payload.messages[0].content)\n\n        if type(self.agent) == ToolCallingAgent:\n            return json.loads(result).get(\"answer\", \"\")\n        elif type(self.agent) == CodeAgent:\n            return str(result)\n        else:\n            return str(result)\n</code></pre>"}]}